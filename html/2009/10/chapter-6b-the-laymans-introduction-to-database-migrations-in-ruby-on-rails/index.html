<!doctype html>
<!-- paulirish.com/2008/conditional-stylesheets-vs-css-hacks-answer-neither/ -->
<!--[if lt IE 7]> <html class="no-js ie6 oldie" lang="en"> <![endif]-->
<!--[if IE 7]>    <html class="no-js ie7 oldie" lang="en"> <![endif]-->
<!--[if IE 8]>    <html class="no-js ie8 oldie" lang="en"> <![endif]-->
<!-- Consider adding a manifest.appcache: h5bp.com/d/Offline -->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en"> <!--<![endif]-->
<head>
  <meta charset="utf-8">

  <!-- Use the .htaccess and remove these lines to avoid edge case issues.
       More info: h5bp.com/b/378 -->
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">

  <title>Chapter 6b - the layman's introduction to database migrations in Ruby on Rails | ignored by dinosaurs</title>
  <meta name="description" content="">
  <meta name="author" content="">

  <!-- Mobile viewport optimized: j.mp/bplateviewport -->
  <meta name="viewport" content="width=device-width,initial-scale=1">

  <!-- Place favicon.ico and apple-touch-icon.png in the root directory: mathiasbynens.be/notes/touch-icons -->

  <link rel="stylesheet" href="/css/style.css">
  
  <!-- More ideas for your <head> here: h5bp.com/d/head-Tips -->

  <!-- All JavaScript at the bottom, except this Modernizr build incl. Respond.js
       Respond is a polyfill for min/max-width media queries. Modernizr enables HTML5 elements & feature detects; 
       for optimal performance, create your own custom Modernizr build: www.modernizr.com/download/ -->
  <script src="js/libs/modernizr-2.0.6.min.js"></script>
</head>

<body>
  <header>
    <a href="/"><h1 id="logo">Ignored By Dinosaurs</h1></a>
    <ul class="nav">
  		<li><a href="/about-ibd">About iBD</a></li>
  		<li><a href="/about-me">Me</a></li>
  		<li><a href="/archive">Archive</a></li>
  		<li><a href="mailto:therealjohnnygrubb@gmail.com">Contact</a></li>
  		<li><a href="https://github.com/JGrubb/ignoredbydinosaurs.com">Source code</a></li>
  		<li><a href="/books">Books</a></li>
  	</ul>
  </header>
  <div role="main">
    <p>This is not for programmers. This is for myself, because when I first started poking at Rails 6 months ago, I didn&#8217;t have any idea why I needed to edit a migration file, much less what a migration was, except that it must have something to do with a database. I only knew that because of the command</p>

<p><code>$&gt;rake db:migrate</code></p>

<p>that I was told to perform and the fact that it had the letters &#8220;db&#8221; in it.</p>

<p>So here&#8217;s the deal. This morning I talked about <a href='http://ignoredByDinosaurs.com/2009/10/chapter-6a-version-control/'>version control</a> and it&#8217;s place in the life cycle of your application. What version control does is keep track of the changes that you make to your applications source code from start to finish (whenever that is). The only problem with this is that a big chunk of the data <em>and</em> functionality of a modern web application doesn&#8217;t reside in the app&#8217;s source code, it resides in the database, and nobody has invented an efficient version control system for a database yet. Some friends of mine have tipped me off to different methods that they&#8217;ve used - mostly around writing down DB schema changes into a text file that then gets placed under version control with the rest of the source. That&#8217;s not entirely efficient, though, is it?</p>

<p>Ruby on Rails has come up with a system called &#8220;migrations&#8221;. Actually, someone surely came up with this way before Rails was invented, but I&#8217;m new here, so feel free to correct me in the comments section down there. Let&#8217;s say you create a new rails app (This is directly from the awesome book &#8221;<a href='http://www.amazon.com/Agile-Web-Development-Rails-Third/dp/1934356166/ref=sr_1_1?ie=UTF8&s=books&qid=1255546866&sr=8-1'>Agile Web Development with Rails</a>&#8221; by a bunch of smart folks, and this example is the beginning of building a shopping cart system) :</p>

<p><code>$&gt;rails newapp</code></p>

<p>This generates a load of boilerplate code which makes up the bones of any Rails app. That means that instead of spending the first week of the development cycle sitting there writing low-level code that provides primordial programmatic structure, you can spend it writing code that actually does something that you (or your client) can interact with. Let&#8217;s keep it as simple as possible and say that you are going to have three fields that will be stored in the database to start. Rails let&#8217;s you run this scaffold generating command:</p>

<p><code>$&gt;ruby script/generate scaffold product title:string description:text image_url:string</code></p>

<p>This command runs a ruby script that builds a LOT of code for you, so much that you&#8217;re only minutes away from tinkering around and you only started a few minutes before that. This command creates the &#8220;products model&#8221;, which is how a programmer says that they are going to start by creating some place for the admin to store the products that they want to sell online. The fields that were initially created were for the name of the product, the description, and the URL where you&#8217;re storing the picture of the product. Don&#8217;t worry about it too much, but take a look at the command up there, it&#8217;ll make sense if you know what a string is. Just know that the data entered into these fields is going to get stored in a database. Wait, how are we gonna store this stuff in our database? Have we even created the tables for the database yet? No. Rails does it for us. Here&#8217;s how.</p>

<p>One of the files that is created when we run that scaffold generator is called a &#8220;migration file&#8221;. This migration file is what actually creates the tables in the database, the columns in the tables, and can even populate the tables with data (used for testing), depending on what you do to the migration file. There is a command (or method if you&#8217;re OOP savvy) created when the scaffold is run called the &#8220;up method&#8221;. That&#8217;s the one that changes your database. There is also a &#8220;down method&#8221;, which is what undoes the changes to your database. When you run the good old <code>rake db:migrate</code> command Rails goes applies the appropriate changes to your database for you, and provides a way to undo them later. So, your client comes in and wants to add a Price column to the store. In the old days, you&#8217;d execute this SQL statement :</p>

<p><code>ALTER TABLE products ADD column price DECIMAL (8,2) NOT NULL;</code></p>

<p>Now, what if you wanted to undo that? That&#8217;s a command you ran there, not some source code that you can save and delete later if you change a few things. You can&#8217;t place SQL statements under version control. You&#8217;d have to go and type that statement into the text file that was under version control, and then hope that you could effectively backtrack to it later if you wanted. If your application and it&#8217;s database have come a ways since that command you&#8217;re going to have a good time figuring out how to undo it. Rails doesn&#8217;t make you do that. In fact, you almost never are going to talk directly to your database in Rails. Instead, you go to the most recent migration file (which <em>is</em> source code and thus under version control) and alter a line to look like this:</p>

<p><code>add_column :products, :price, :decimal, :precision =&gt; 8, :scale =&gt; 2, :default =&gt; 0</code></p>

<p>Then you run a script that alters the database for you. Below this add column instruction, or &#8220;up method&#8221;, you add the remove column instruction, or &#8220;down method&#8221;:</p>

<p><code>remove_column :products, :price</code></p>

<p>This is the undo button for your database and any schema changes along the way. Since this command is under version control, and since you&#8217;re not directly interacting with your database, and since Rails knows how and which migrations to apply and in what order if you ever want to go back to a previous version, you&#8217;ve just made your life a LOT easier. Now if you only understood what the hell you were talking about!!</p>

<p>For a vastly better explanation, <a href='http://guides.rubyonrails.org/migrations.html'>try here</a>.</p>

<p>Good luck.</p>
  </div>
  <footer>

  </footer>


  <!-- JavaScript at the bottom for fast page loading -->

  <!-- Grab Google CDN's jQuery, with a protocol relative URL; fall back to local if offline -->
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.6.4/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="js/libs/jquery-1.6.4.min.js"><\/script>')</script>


  <!-- scripts concatenated and minified via build script -->
  <script defer src="js/plugins.js"></script>
  <script defer src="js/script.js"></script>
  <!-- end scripts -->


  <!-- Asynchronous Google Analytics snippet. Change UA-XXXXX-X to be your site's ID.
       mathiasbynens.be/notes/async-analytics-snippet -->
  <script>
    var _gaq=[['_setAccount','UA-XXXXX-X'],['_trackPageview'],['_trackPageLoadTime']];
    (function(d,t){var g=d.createElement(t),s=d.getElementsByTagName(t)[0];
    g.src=('https:'==location.protocol?'//ssl':'//www')+'.google-analytics.com/ga.js';
    s.parentNode.insertBefore(g,s)}(document,'script'));
  </script>

  <!-- Prompt IE 6 users to install Chrome Frame. Remove this if you want to support IE 6.
       chromium.org/developers/how-tos/chrome-frame-getting-started -->
  <!--[if lt IE 7 ]>
    <script defer src="//ajax.googleapis.com/ajax/libs/chrome-frame/1.0.3/CFInstall.min.js"></script>
    <script defer>window.attachEvent('onload',function(){CFInstall.check({mode:'overlay'})})</script>
  <![endif]-->

</body>
</html>
